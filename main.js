/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/git/executor.ts
var import_child_process = require("child_process");
var import_util = require("util");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var GitExecutor = class {
  constructor(gitPath = "git", workingDir) {
    this.gitPath = gitPath;
    this.workingDir = workingDir;
  }
  /**
   * Execute a git command
   */
  async run(command) {
    try {
      const result = await execAsync(`${this.gitPath} ${command}`, {
        cwd: this.workingDir,
        maxBuffer: 50 * 1024 * 1024,
        // 50MB buffer
        timeout: 12e4
        // 2 minute timeout
      });
      return result;
    } catch (error) {
      const gitError = new Error(error.message);
      gitError.code = error.code;
      gitError.stderr = error.stderr || "";
      gitError.stdout = error.stdout || "";
      throw gitError;
    }
  }
  /**
   * Check if git is available
   */
  async isGitAvailable() {
    try {
      await execAsync(`${this.gitPath} --version`);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if current directory is a git repository
   */
  async isRepo() {
    try {
      await this.run("rev-parse --is-inside-work-tree");
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Initialize a new git repository
   */
  async init() {
    await this.run("init");
  }
  /**
   * Get current branch name
   */
  async getCurrentBranch() {
    const result = await this.run("rev-parse --abbrev-ref HEAD");
    return result.stdout.trim();
  }
  /**
   * Get remote name (usually 'origin')
   */
  async getRemoteName() {
    try {
      const result = await this.run("remote");
      const remotes = result.stdout.trim().split("\n").filter(Boolean);
      return remotes.includes("origin") ? "origin" : remotes[0] || null;
    } catch (e) {
      return null;
    }
  }
  /**
   * Get current remote URL
   */
  async getRemoteUrl() {
    try {
      const remote = await this.getRemoteName();
      if (!remote)
        return null;
      const result = await this.run(`remote get-url ${remote}`);
      return result.stdout.trim();
    } catch (e) {
      return null;
    }
  }
  /**
   * Fetch from remote
   */
  async fetch() {
    const remote = await this.getRemoteName();
    if (remote) {
      await this.run(`fetch ${remote}`);
    }
  }
  /**
   * Get detailed status of repository
   */
  async status() {
    const result = await this.run("status --porcelain=v1 --branch");
    const lines = result.stdout.trim().split("\n").filter(Boolean);
    const branchLine = lines[0] || "";
    const statusLines = lines.slice(1);
    const branchMatch = branchLine.match(/^## (?:No branch|\S+)(?:\.\.\.\S+)?(?:\s+\[(?:ahead (\d+))?(?:, )?(?:behind (\d+))?\])?/);
    const branch = branchLine.replace(/^## /, "").split("...")[0].split(" ")[0];
    const ahead = (branchMatch == null ? void 0 : branchMatch[1]) ? parseInt(branchMatch[1]) : 0;
    const behind = (branchMatch == null ? void 0 : branchMatch[2]) ? parseInt(branchMatch[2]) : 0;
    const staged = [];
    const modified = [];
    const untracked = [];
    const conflicts = [];
    for (const line of statusLines) {
      const indexStatus = line[0];
      const workTreeStatus = line[1];
      const fileName = line.substring(3);
      if (indexStatus === "U" || workTreeStatus === "U" || indexStatus === "A" && workTreeStatus === "A" || indexStatus === "D" && workTreeStatus === "D") {
        conflicts.push(fileName);
        continue;
      }
      if (indexStatus !== " " && indexStatus !== "?") {
        staged.push(fileName);
      }
      if (workTreeStatus !== " " && workTreeStatus !== "?") {
        modified.push(fileName);
      }
      if (indexStatus === "?" && workTreeStatus === "?") {
        untracked.push(fileName);
      }
    }
    return {
      isRepo: true,
      branch: branch === "HEAD" ? "(detached)" : branch,
      ahead,
      behind,
      staged,
      modified,
      untracked,
      conflicts,
      clean: staged.length === 0 && modified.length === 0 && untracked.length === 0 && conflicts.length === 0
    };
  }
  /**
   * Check if there are any conflicts
   */
  async hasConflicts() {
    try {
      const result = await this.run("diff --name-only --diff-filter=U");
      return result.stdout.trim().length > 0;
    } catch (e) {
      return false;
    }
  }
  /**
   * Add all changes to staging
   */
  async addAll() {
    await this.run("add -A");
  }
  /**
   * Add specific files to staging
   */
  async add(files) {
    if (files.length === 0)
      return;
    const escapedFiles = files.map((f) => `"${f.replace(/"/g, '\\"')}"`).join(" ");
    await this.run(`add ${escapedFiles}`);
  }
  /**
   * Commit changes
   */
  async commit(message) {
    var _a;
    try {
      await this.run(`commit -m "${message.replace(/"/g, '\\"')}"`);
      return { success: true, message: "Commit successful", files: 0 };
    } catch (error) {
      if ((_a = error.stdout) == null ? void 0 : _a.includes("nothing to commit")) {
        return { success: true, message: "Nothing to commit", files: 0 };
      }
      throw error;
    }
  }
  /**
   * Pull from remote
   */
  async pull() {
    try {
      const branch = await this.getCurrentBranch();
      const remote = await this.getRemoteName();
      if (!remote) {
        return { success: false, message: "No remote configured", files: [], conflicts: [] };
      }
      await this.fetch();
      const status = await this.status();
      if (status.modified.length > 0 || status.staged.length > 0) {
        await this.run('stash push -m "obsidian-git-sync-auto-stash"');
      }
      const result = await this.run(`pull ${remote} ${branch} --rebase`);
      try {
        await this.run("stash pop");
      } catch (e) {
      }
      const files = this.parsePullFiles(result.stdout);
      return { success: true, message: "Pull successful", files, conflicts: [] };
    } catch (error) {
      if (await this.hasConflicts()) {
        const conflictFiles = await this.getConflictFiles();
        return {
          success: false,
          message: "Merge conflicts detected",
          files: [],
          conflicts: conflictFiles
        };
      }
      throw error;
    }
  }
  /**
   * Push to remote
   */
  async push() {
    try {
      const branch = await this.getCurrentBranch();
      const remote = await this.getRemoteName();
      if (!remote) {
        return { success: false, message: "No remote configured", pushed: 0 };
      }
      await this.run(`push ${remote} ${branch}`);
      return { success: true, message: "Push successful", pushed: 1 };
    } catch (error) {
      throw error;
    }
  }
  /**
   * Push with --set-upstream flag for new branches
   */
  async pushWithUpstream() {
    try {
      const branch = await this.getCurrentBranch();
      const remote = await this.getRemoteName();
      if (!remote) {
        return { success: false, message: "No remote configured", pushed: 0 };
      }
      await this.run(`push -u ${remote} ${branch}`);
      return { success: true, message: "Push successful", pushed: 1 };
    } catch (error) {
      throw error;
    }
  }
  /**
   * Get list of conflict files
   */
  async getConflictFiles() {
    try {
      const result = await this.run("diff --name-only --diff-filter=U");
      return result.stdout.trim().split("\n").filter(Boolean);
    } catch (e) {
      return [];
    }
  }
  /**
   * Parse files changed from pull output
   */
  parsePullFiles(output) {
    const files = [];
    const lines = output.split("\n");
    for (const line of lines) {
      const match = line.match(/^\s+(.+?)\s*\|/);
      if (match) {
        files.push(match[1].trim());
      }
    }
    return files;
  }
  /**
   * Get log of recent commits
   */
  async log(count = 5) {
    const result = await this.run(`log --oneline -${count}`);
    return result.stdout.trim().split("\n").filter(Boolean);
  }
  /**
   * Check if there's an upstream branch
   */
  async hasUpstream() {
    try {
      const branch = await this.getCurrentBranch();
      await this.run(`rev-parse --abbrev-ref ${branch}@{upstream}`);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Set upstream branch
   */
  async setUpstream() {
    const branch = await this.getCurrentBranch();
    const remote = await this.getRemoteName();
    if (remote) {
      await this.run(`branch --set-upstream-to=${remote}/${branch}`);
    }
  }
  /**
   * Abort an ongoing rebase
   */
  async abortRebase() {
    await this.run("rebase --abort");
  }
  /**
   * Abort an ongoing merge
   */
  async abortMerge() {
    await this.run("merge --abort");
  }
  /**
   * Configure git user name
   */
  async setUserName(name) {
    await this.run(`config user.name "${name}"`);
  }
  /**
   * Configure git user email
   */
  async setUserEmail(email) {
    await this.run(`config user.email "${email}"`);
  }
  /**
   * Get git user name
   */
  async getUserName() {
    try {
      const result = await this.run("config user.name");
      return result.stdout.trim() || null;
    } catch (e) {
      return null;
    }
  }
  /**
   * Get git user email
   */
  async getUserEmail() {
    try {
      const result = await this.run("config user.email");
      return result.stdout.trim() || null;
    } catch (e) {
      return null;
    }
  }
};

// src/utils/helpers.ts
function formatDate(date = /* @__PURE__ */ new Date()) {
  return date.toISOString().replace(/T/, " ").replace(/\..+/, "");
}
function generateCommitMessage(template) {
  const now = /* @__PURE__ */ new Date();
  return template.replace(/\{\{date\}\}/g, formatDate(now)).replace(/\{\{datetime\}\}/g, formatDate(now)).replace(/\{\{timestamp\}\}/g, now.getTime().toString()).replace(/\{\{isoDate\}\}/g, now.toISOString()).replace(/\{\{time\}\}/g, now.toTimeString().split(" ")[0]);
}

// src/sync/sync-manager.ts
var SyncManager = class {
  constructor(plugin) {
    this.syncLock = false;
    this.autoSyncInterval = null;
    this.onStatusChange = null;
    this.lastSyncTime = null;
    this.lastSyncResult = null;
    this.plugin = plugin;
    this.git = new GitExecutor(plugin.settings.gitPath, this.getVaultPath());
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    return this.plugin.app.vault.adapter.basePath;
  }
  /**
   * Set the status change callback
   */
  setStatusCallback(callback) {
    this.onStatusChange = callback;
  }
  /**
   * Update status and notify callback
   */
  updateStatus(status, message) {
    if (this.onStatusChange) {
      this.onStatusChange(status, message);
    }
  }
  /**
   * Check if sync is in progress
   */
  isSyncing() {
    return this.syncLock;
  }
  /**
   * Check if git is available and repository is initialized
   */
  async checkGitStatus() {
    const gitAvailable = await this.git.isGitAvailable();
    if (!gitAvailable) {
      return { available: false, isRepo: false, error: "Git is not installed or not found in PATH" };
    }
    const isRepo = await this.git.isRepo();
    return { available: true, isRepo };
  }
  /**
   * Initialize repository
   */
  async initRepo() {
    await this.git.init();
  }
  /**
   * Get current git status
   */
  async getStatus() {
    return await this.git.status();
  }
  /**
   * Perform a full sync: pull -> commit -> push
   */
  async sync() {
    if (this.syncLock) {
      return { success: false, message: "Sync already in progress" };
    }
    this.syncLock = true;
    try {
      const { available, isRepo, error } = await this.checkGitStatus();
      if (!available) {
        this.updateStatus("error", error || "Git not available");
        return { success: false, message: error || "Git not available" };
      }
      if (!isRepo) {
        this.updateStatus("error", "Not a git repository");
        return { success: false, message: "Not a git repository. Please initialize a git repository first." };
      }
      if (await this.git.hasConflicts()) {
        this.updateStatus("conflict", "Merge conflicts detected");
        return { success: false, message: "Merge conflicts detected. Please resolve them manually.", conflicts: [] };
      }
      this.updateStatus("pulling", "Pulling changes...");
      const pullResult = await this.pullOnly();
      if (!pullResult.success && pullResult.conflicts.length > 0) {
        this.updateStatus("conflict", "Merge conflicts detected");
        this.lastSyncResult = { success: false, message: "Merge conflicts after pull", conflicts: pullResult.conflicts };
        return this.lastSyncResult;
      }
      this.updateStatus("pushing", "Committing and pushing changes...");
      const pushResult = await this.commitAndPush();
      if (pushResult.success) {
        this.updateStatus("success", "Sync completed successfully");
        this.lastSyncTime = /* @__PURE__ */ new Date();
        this.lastSyncResult = { success: true, message: "Sync completed", pulled: pullResult.files.length, pushed: pushResult.pushed };
        return this.lastSyncResult;
      } else {
        this.updateStatus("error", pushResult.message);
        this.lastSyncResult = { success: false, message: pushResult.message };
        return this.lastSyncResult;
      }
    } catch (error) {
      const message = error.message || "Unknown error during sync";
      this.updateStatus("error", message);
      this.lastSyncResult = { success: false, message };
      return this.lastSyncResult;
    } finally {
      this.syncLock = false;
    }
  }
  /**
   * Pull changes from remote
   */
  async pullOnly() {
    try {
      const remote = await this.git.getRemoteName();
      if (!remote) {
        return { success: true, message: "No remote configured, skipping pull", files: [], conflicts: [] };
      }
      await this.git.fetch();
      const status = await this.git.status();
      if (status.behind === 0) {
        return { success: true, message: "Already up to date", files: [], conflicts: [] };
      }
      this.updateStatus("pulling", "Pulling changes...");
      const result = await this.git.pull();
      return result;
    } catch (error) {
      if (await this.git.hasConflicts()) {
        const conflictFiles = await this.getStatus().then((s) => s.conflicts);
        this.updateStatus("conflict", "Merge conflicts detected");
        return { success: false, message: "Merge conflicts detected", files: [], conflicts: conflictFiles };
      }
      throw error;
    }
  }
  /**
   * Commit all changes and push to remote
   */
  async commitAndPush() {
    var _a;
    try {
      const status = await this.git.status();
      if (status.clean) {
        if (status.ahead > 0) {
          this.updateStatus("pushing", "Pushing changes...");
          return await this.git.push();
        }
        return { success: true, message: "Nothing to commit or push", pushed: 0 };
      }
      await this.git.addAll();
      const message = generateCommitMessage(this.plugin.settings.commitMessage);
      await this.git.commit(message);
      const hasUpstream = await this.git.hasUpstream();
      this.updateStatus("pushing", "Pushing changes...");
      if (hasUpstream) {
        return await this.git.push();
      } else {
        return await this.git.pushWithUpstream();
      }
    } catch (error) {
      if ((_a = error.stdout) == null ? void 0 : _a.includes("nothing to commit")) {
        try {
          return await this.git.push();
        } catch (pushError) {
          return { success: false, message: pushError.message, pushed: 0 };
        }
      }
      return { success: false, message: error.message, pushed: 0 };
    }
  }
  /**
   * Get last sync result
   */
  getLastSyncResult() {
    return this.lastSyncResult;
  }
  /**
   * Get last sync time
   */
  getLastSyncTime() {
    return this.lastSyncTime;
  }
  /**
   * Start automatic sync
   */
  startAutoSync() {
    if (this.autoSyncInterval !== null) {
      this.stopAutoSync();
    }
    const intervalMs = this.plugin.settings.syncInterval * 60 * 1e3;
    this.autoSyncInterval = window.setInterval(() => {
      this.sync().catch((error) => {
        console.error("Auto-sync error:", error);
      });
    }, intervalMs);
    this.plugin.registerInterval(this.autoSyncInterval);
  }
  /**
   * Stop automatic sync
   */
  stopAutoSync() {
    if (this.autoSyncInterval !== null) {
      window.clearInterval(this.autoSyncInterval);
      this.autoSyncInterval = null;
    }
  }
  /**
   * Restart automatic sync (use after settings change)
   */
  restartAutoSync() {
    if (this.plugin.settings.autoSync) {
      this.stopAutoSync();
      this.startAutoSync();
    } else {
      this.stopAutoSync();
    }
  }
  /**
   * Initialize sync manager
   */
  async initialize() {
    const { available, isRepo } = await this.checkGitStatus();
    if (!available) {
      this.updateStatus("error", "Git not available");
      return;
    }
    if (!isRepo) {
      this.updateStatus("error", "Not a git repository");
      return;
    }
    if (this.plugin.settings.autoPullOnStart) {
      try {
        await this.pullOnly();
      } catch (error) {
        console.error("Auto-pull error:", error);
      }
    }
    if (this.plugin.settings.autoSync) {
      this.startAutoSync();
    }
    this.updateStatus("idle", "Ready");
  }
  /**
   * Dispose the sync manager
   */
  dispose() {
    this.stopAutoSync();
  }
};

// src/ui/status-bar.ts
var import_obsidian = require("obsidian");
var StatusBar = class {
  constructor(plugin) {
    this.statusBarEl = null;
    this.iconEl = null;
    this.textEl = null;
    this.plugin = plugin;
  }
  /**
   * Initialize the status bar
   */
  initialize() {
    if (!this.plugin.settings.showStatusBar) {
      return;
    }
    this.statusBarEl = this.plugin.addStatusBarItem();
    this.statusBarEl.addClass("git-sync-status-bar");
    this.iconEl = this.statusBarEl.createSpan({ cls: "git-sync-status-icon" });
    this.textEl = this.statusBarEl.createSpan({ cls: "git-sync-status-text" });
    this.statusBarEl.addEventListener("click", () => {
      this.plugin.sync();
    });
    this.updateStatus("idle", "Ready");
  }
  /**
   * Update the status bar display
   */
  updateStatus(status, message) {
    if (!this.statusBarEl || !this.iconEl || !this.textEl) {
      return;
    }
    this.statusBarEl.removeClass("syncing");
    this.statusBarEl.removeClass("error");
    this.statusBarEl.removeClass("success");
    this.statusBarEl.removeClass("conflict");
    switch (status) {
      case "idle":
        (0, import_obsidian.setIcon)(this.iconEl, "git-branch");
        this.textEl.setText(message || "Ready");
        break;
      case "syncing":
        this.statusBarEl.addClass("syncing");
        (0, import_obsidian.setIcon)(this.iconEl, "sync");
        this.textEl.setText(message || "Syncing...");
        break;
      case "pulling":
        this.statusBarEl.addClass("syncing");
        (0, import_obsidian.setIcon)(this.iconEl, "arrow-down");
        this.textEl.setText(message || "Pulling...");
        break;
      case "pushing":
        this.statusBarEl.addClass("syncing");
        (0, import_obsidian.setIcon)(this.iconEl, "arrow-up");
        this.textEl.setText(message || "Pushing...");
        break;
      case "committing":
        this.statusBarEl.addClass("syncing");
        (0, import_obsidian.setIcon)(this.iconEl, "check");
        this.textEl.setText(message || "Committing...");
        break;
      case "success":
        this.statusBarEl.addClass("success");
        (0, import_obsidian.setIcon)(this.iconEl, "check-circle");
        this.textEl.setText(message || "Sync complete");
        setTimeout(() => {
          if (this.statusBarEl && this.statusBarEl.hasClass("success")) {
            this.updateStatus("idle", "Ready");
          }
        }, 3e3);
        break;
      case "error":
        this.statusBarEl.addClass("error");
        (0, import_obsidian.setIcon)(this.iconEl, "alert-circle");
        this.textEl.setText(message || "Error");
        break;
      case "conflict":
        this.statusBarEl.addClass("conflict");
        (0, import_obsidian.setIcon)(this.iconEl, "alert-triangle");
        this.textEl.setText(message || "Conflicts");
        break;
    }
  }
  /**
   * Show the status bar
   */
  show() {
    if (this.statusBarEl) {
      this.statusBarEl.style.display = "flex";
    }
  }
  /**
   * Hide the status bar
   */
  hide() {
    if (this.statusBarEl) {
      this.statusBarEl.style.display = "none";
    }
  }
  /**
   * Remove the status bar
   */
  destroy() {
    if (this.statusBarEl) {
      this.statusBarEl.remove();
      this.statusBarEl = null;
      this.iconEl = null;
      this.textEl = null;
    }
  }
};

// src/ui/settings-tab.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  autoSync: false,
  syncInterval: 10,
  commitMessage: "vault backup: {{date}}",
  autoPullOnStart: true,
  showStatusBar: true,
  gitPath: "git",
  excludePatterns: [],
  showNotifications: true
};
var GitSyncSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("git-sync-settings");
    containerEl.createEl("h2", { text: "Git Sync Settings" });
    this.createStatusSection();
    containerEl.createEl("h3", { text: "Sync Settings" });
    new import_obsidian2.Setting(containerEl).setName("Automatic sync").setDesc("Enable automatic synchronization at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      this.plugin.restartAutoSync();
    }));
    new import_obsidian2.Setting(containerEl).setName("Sync interval").setDesc("Time between automatic syncs in minutes (minimum 1)").addText((text) => text.setValue(String(this.plugin.settings.syncInterval)).setPlaceholder("10").onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1) {
        this.plugin.settings.syncInterval = num;
        await this.plugin.saveSettings();
        this.plugin.restartAutoSync();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto pull on start").setDesc("Automatically pull changes when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoPullOnStart).onChange(async (value) => {
      this.plugin.settings.autoPullOnStart = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Commit Settings" });
    new import_obsidian2.Setting(containerEl).setName("Commit message").setDesc("Template for commit messages. Supports: {{date}}, {{datetime}}, {{time}}, {{timestamp}}, {{isoDate}}").addText((text) => text.setValue(this.plugin.settings.commitMessage).setPlaceholder("vault backup: {{date}}").onChange(async (value) => {
      this.plugin.settings.commitMessage = value || DEFAULT_SETTINGS.commitMessage;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Settings" });
    new import_obsidian2.Setting(containerEl).setName("Show status bar").setDesc("Display sync status in the status bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusBar).onChange(async (value) => {
      this.plugin.settings.showStatusBar = value;
      await this.plugin.saveSettings();
      this.plugin.updateStatusBarVisibility();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show notifications").setDesc("Show notifications for sync events").addToggle((toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
      this.plugin.settings.showNotifications = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Git Settings" });
    new import_obsidian2.Setting(containerEl).setName("Git path").setDesc('Path to the git executable. Default is "git" which uses system PATH.').addText((text) => text.setValue(this.plugin.settings.gitPath).setPlaceholder("git").onChange(async (value) => {
      this.plugin.settings.gitPath = value || DEFAULT_SETTINGS.gitPath;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Actions" });
    new import_obsidian2.Setting(containerEl).setName("Sync now").setDesc("Perform a full sync (pull, commit, push)").addButton((button) => button.setButtonText("Sync").setCta().onClick(async () => {
      await this.plugin.sync();
    }));
    new import_obsidian2.Setting(containerEl).setName("Pull from remote").setDesc("Pull changes from the remote repository").addButton((button) => button.setButtonText("Pull").onClick(async () => {
      await this.plugin.pull();
    }));
    new import_obsidian2.Setting(containerEl).setName("Commit and push").setDesc("Commit all changes and push to remote").addButton((button) => button.setButtonText("Push").onClick(async () => {
      await this.plugin.commitAndPush();
    }));
    containerEl.createEl("h3", { text: "Help" });
    const helpDiv = containerEl.createDiv();
    helpDiv.innerHTML = `
      <p>This plugin syncs your vault with a Git repository.</p>
      <p><strong>Prerequisites:</strong></p>
      <ul>
        <li>Git must be installed on your system</li>
        <li>Your vault must be a Git repository (git init)</li>
        <li>A remote must be configured (git remote add origin &lt;url&gt;)</li>
        <li>Git credentials must be set up for push/pull operations</li>
      </ul>
      <p><strong>Note:</strong> This plugin only works on desktop (Windows, macOS, Linux).</p>
    `;
  }
  /**
   * Create status section
   */
  createStatusSection() {
    const { containerEl } = this;
    const statusContainer = containerEl.createDiv({ cls: "status-container" });
    statusContainer.createEl("h4", { text: "Repository Status" });
    this.checkGitStatus(statusContainer);
  }
  /**
   * Check and display git status
   */
  async checkGitStatus(container) {
    const gitAvailable = await this.plugin.isGitAvailable();
    const isRepo = await this.plugin.isRepo();
    const items = [
      { label: "Git installed", value: gitAvailable ? "Yes" : "No", status: gitAvailable ? "success" : "error" },
      { label: "Git repository", value: isRepo ? "Yes" : "No", status: isRepo ? "success" : "error" }
    ];
    if (isRepo) {
      try {
        const status = await this.plugin.getGitStatus();
        items.push({
          label: "Current branch",
          value: status.branch,
          status: "normal"
        });
        items.push({
          label: "Changes",
          value: status.clean ? "None" : `${status.staged.length + status.modified.length + status.untracked.length} files`,
          status: status.clean ? "success" : "warning"
        });
      } catch (error) {
        items.push({
          label: "Status",
          value: "Error reading status",
          status: "error"
        });
      }
    }
    for (const item of items) {
      const itemEl = container.createDiv({ cls: "status-item" });
      itemEl.createSpan({ cls: "status-label", text: item.label });
      itemEl.createSpan({ cls: `status-value ${item.status}`, text: item.value });
    }
  }
};

// main.ts
var GitSyncPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Git Sync plugin");
    await this.loadSettings();
    this.git = new GitExecutor(this.settings.gitPath, this.getVaultPath());
    this.statusBar = new StatusBar(this);
    this.statusBar.initialize();
    this.syncManager = new SyncManager(this);
    this.syncManager.setStatusCallback((status, message) => {
      this.statusBar.updateStatus(status, message);
    });
    this.addSettingTab(new GitSyncSettingTab(this.app, this));
    this.registerCommands();
    this.addRibbonIcon("git-branch", "Git Sync", () => {
      this.sync();
    });
    await this.syncManager.initialize();
  }
  onunload() {
    console.log("Unloading Git Sync plugin");
    this.syncManager.dispose();
    this.statusBar.destroy();
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    return this.app.vault.adapter.basePath;
  }
  /**
   * Load plugin settings
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save plugin settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Register plugin commands
   */
  registerCommands() {
    this.addCommand({
      id: "git-sync",
      name: "Sync with remote",
      callback: () => this.sync()
    });
    this.addCommand({
      id: "git-pull",
      name: "Pull from remote",
      callback: () => this.pull()
    });
    this.addCommand({
      id: "git-push",
      name: "Commit and push",
      callback: () => this.commitAndPush()
    });
    this.addCommand({
      id: "git-status",
      name: "Show Git status",
      callback: () => this.showStatus()
    });
    this.addCommand({
      id: "git-init",
      name: "Initialize Git repository",
      callback: () => this.initRepo()
    });
  }
  /**
   * Perform full sync
   */
  async sync() {
    if (this.syncManager.isSyncing()) {
      this.showNotice("Sync already in progress");
      return;
    }
    this.showNotice("Starting sync...");
    const result = await this.syncManager.sync();
    if (result.success) {
      this.showNotice(result.message);
    } else {
      this.showNotice(`Sync failed: ${result.message}`, true);
    }
  }
  /**
   * Pull from remote
   */
  async pull() {
    if (this.syncManager.isSyncing()) {
      this.showNotice("Sync already in progress");
      return;
    }
    const result = await this.syncManager.pullOnly();
    if (result.success) {
      this.showNotice(result.message);
    } else {
      this.showNotice(`Pull failed: ${result.message}`, true);
    }
  }
  /**
   * Commit and push
   */
  async commitAndPush() {
    if (this.syncManager.isSyncing()) {
      this.showNotice("Sync already in progress");
      return;
    }
    const result = await this.syncManager.commitAndPush();
    if (result.success) {
      this.showNotice(result.message);
    } else {
      this.showNotice(`Push failed: ${result.message}`, true);
    }
  }
  /**
   * Show git status
   */
  async showStatus() {
    const { available, isRepo, error } = await this.checkGitStatus();
    if (!available) {
      this.showNotice(`Git not available: ${error}`, true);
      return;
    }
    if (!isRepo) {
      this.showNotice('Not a git repository. Use "Initialize Git repository" command to create one.', true);
      return;
    }
    const status = await this.getGitStatus();
    const lines = [];
    lines.push(`Branch: ${status.branch}`);
    if (status.clean) {
      lines.push("Status: Clean");
    } else {
      if (status.staged.length > 0) {
        lines.push(`Staged: ${status.staged.length} files`);
      }
      if (status.modified.length > 0) {
        lines.push(`Modified: ${status.modified.length} files`);
      }
      if (status.untracked.length > 0) {
        lines.push(`Untracked: ${status.untracked.length} files`);
      }
      if (status.conflicts.length > 0) {
        lines.push(`Conflicts: ${status.conflicts.length} files`);
      }
    }
    if (status.ahead > 0) {
      lines.push(`Ahead: ${status.ahead} commits`);
    }
    if (status.behind > 0) {
      lines.push(`Behind: ${status.behind} commits`);
    }
    this.showNotice(lines.join("\n"));
  }
  /**
   * Initialize repository
   */
  async initRepo() {
    const { isRepo } = await this.checkGitStatus();
    if (isRepo) {
      this.showNotice("Already a git repository");
      return;
    }
    try {
      await this.git.init();
      this.showNotice("Git repository initialized");
    } catch (error) {
      this.showNotice(`Failed to initialize repository: ${error.message}`, true);
    }
  }
  /**
   * Check git status
   */
  async checkGitStatus() {
    const available = await this.git.isGitAvailable();
    if (!available) {
      return { available: false, isRepo: false, error: "Git is not installed or not found in PATH" };
    }
    const isRepo = await this.git.isRepo();
    return { available: true, isRepo };
  }
  /**
   * Check if git is available
   */
  async isGitAvailable() {
    return await this.git.isGitAvailable();
  }
  /**
   * Check if current directory is a git repository
   */
  async isRepo() {
    return await this.git.isRepo();
  }
  /**
   * Get git status
   */
  async getGitStatus() {
    return await this.git.status();
  }
  /**
   * Restart auto sync
   */
  restartAutoSync() {
    this.syncManager.restartAutoSync();
  }
  /**
   * Update status bar visibility
   */
  updateStatusBarVisibility() {
    if (this.settings.showStatusBar) {
      this.statusBar.show();
    } else {
      this.statusBar.hide();
    }
  }
  /**
   * Show notice (notification)
   */
  showNotice(message, isError = false) {
    if (!this.settings.showNotifications) {
      return;
    }
    if (isError) {
      new import_obsidian3.Notice(`Git Sync: ${message}`, 5e3);
    } else {
      new import_obsidian3.Notice(`Git Sync: ${message}`);
    }
  }
};
